プロパティアクセス式の事例の最後でa[2]["1"]で式a[2]のインデックス1の要素の値を参照するというものだが、これはa[2][1]ではダメなのか？
-> よい。そもそも[]内は文字列にキャストされるので、a[2][1]はa[2]["1"]と同じ意味になる。

0除算でエラーになる言語もあるが、なぜ JavaScript ではエラーにならないのでしょうか？
-> 0除算はエラーにならない。Infinityがあるから(一応)表現可能
IEEE-754の浮動小数点数の仕様に従っているため、0除算はInfinityになる。
https://learn.microsoft.com/ja-jp/windows/uwp/graphics-concepts/floating-point-rules

+を1つの式で2つの意味で使う場面があるのでしょうか。テンプレートリテラルを使うべきなのではないかと思いました。
-> っhttps://eslint.org/docs/latest/rules/prefer-template

BigInt値に単項プラス演算子を使うとTypeErrorになりました。通常、数値に変換できない場合NaNになると思うのですが、何故TypeErrorになるのでしょうか？
-> BigIntは通常の数値に変換できないため、TypeErrorになる。NaNは数値型の値であるため、BigIntは数値型ではないのでエラーになる。

単項プラス演算子はNumber()と同じ役割になると思うのですが、Number（）ではなく、単項プラス演算子を使う必要性のある場面というのはあるのでしょうか？Number（）と全く同じと思えば良いのでしょうか？
->あまりない。

「BigInt値は通常の数値に変換ができない」のは、単に仕組みがないだけなのか、何か変換できない背景があるのか
-> 仕組みがない。BigIntは整数を表すための型であり、通常の数値は浮動小数点数を表すための型であるため、変換できない。

javascriptでビット演算子を利用する場面は、どのような時でしょうか？マイコン等の性能が低いCPUを利用しているならまだしも、現代の計算リソースの性能を考えたときにわざわざ活用する必要性は無いと感じています。
-> 基本型しか入らないDBを使っていて、かつbool値型のフラグがたくさんあるような場合はビット演算子を使うとフラグをまとめて1つの数値に格納できるのでコンパクトで見やすい
https://eslint.org/docs/latest/rules/no-bitwise

「小なりイコール演算子や大なりイコール演算子は２つの値が等しいかどうかを判定するために等値演算子や同値演算子を使いません」とありますが、わざわざこのような解説があるということは、つまり２つの値が等しい時に等値演算子と同値演算子と違う動きをするということだと思いますが、それはどういう場合でしょうか？
-> 等値演算子や同値演算子で行われるような型変換は行われないため、文字列や数値以外の型の値を比較する場合は、型が異なるとfalseになる。
console.log(null == undefined);
console.log(null >= undefined);

console.log(undefined === undefined);
console.log(undefined >= undefined);

「eval()を関数として定義しているために、ほかの名前を付けられるという問題も発生します」とあるのですが、一般的にはevalという存在を知らず、変数を定義して上書きして使ってしまうことが多いのでしょうか。これは問題ないのでしょうか。
-> eval()は関数として定義されているため、evalという名前の変数を定義して上書きしてしまうことがある。上書きしてしまっているのであれば問題ないが、そもそもeval()を使うこと自体があまり好ましくないため、eval()を使う必要がある場合はevalという名前の変数を定義しない方が良い。

eval() はどのような場面で使うのでしょうか？
-> eval()は、Ajaxなどの非同期通信で、サーバーから受け取ったデータをJavaScriptのコードとして実行する場合などに使われることがある。ただし、セキュリティ上の問題があるため、あまり使わない方が良い。

「オペランドの値がnullの場合も、typeofは"object"という文字列を返すことに注意してください」とあるが、どうしてtypeof nullは"null"ではなく、"object"なのでしょうか？どこかで便利な場面があるのでしょうか？
-> これはJavaScriptの仕様上のバグであり、nullはオブジェクトではないため、typeof nullは"object"を返す。

typeof null はなぜ 'object' というのを返すのでしょうか？知らなければバグの原因になりそうです。
-> これはJavaScriptの仕様上のバグであり、nullはオブジェクトではないため、typeof nullは"object"を返す。

JavaScriptのオブジェクトのプロパティが追加・削除可能だとしてもオブジェクト指向的な考え(クラス設計を前提に考える)からするとあまりそのような操作は好ましくない気がしますが、delete演算子を使うと良いケースはなにかありますか？
"パターンマッチングに関して２つ質問があります。
①switchがJavaScriptでは文のみサポートで、switch式が実装されない理由はありますか？JavaやC#でも標準化されていてJSでも使えて良いと思うのですが
②例えば問題5-3のように、入力にマッチした値を返すような実装では、入力側の仕様変更(5-3の例だと、後から暦が変更され13月31日が生まれたなど)に気づかないでswitchやif内の条件側のコード修正が漏れると意図しない結果が返る可能性があります。
この問題を防止できるような実装があれば教えてください。"
「ループ本体は3 回しか実行されません。つまり、"I"、" ♥"、"🐈 "という3 つの符号位置につき1 度ずつしかループ本体は実行されないのです。」とありますが、これで良いのではないでしょうか。lengthに合わせる必要があるときはあるのでしょうか。
-> ES6かSymbol.iteratorが実装されたのでよりユースケースに近い実装となったと予想

for ofではなくfor inをあえて使う場面はあるのでしょうか？プロパティの列挙においてもfor of + Object.keys()の方が何をしているか明確で読み手に親切な気がします。
-> そう思う
"ラベル文は開発でよく使われるのでしょうか？
実装経験が浅いためか、見たことがなく、、"
-> ラベル文はあまり使われない。ラベル文は、ループを抜けるために使われることが多いが、あまり使われないため、あまり見かけない。

try-catch-finally文でtry文やcatch文にreturn文が無ければ、finally文に記載しても、try-catch文の後に普通に記載しても同じ動きになると思っているのですが、この理解で合っているでしょうか？また、その場合、finally文に記載するメリットは可読性（コードの意図を伝える）ということになるのでしょうか？
-> その理解で合っている。

finally文の後始末処理というのは具体的にはどういったものがあるのでしょうか？リソースの解放とか？
-> リソースの解放や、ファイルのクローズなどがある。ただ最近のライブラリでは、finally文を使わずに、Promiseを使って非同期処理を行うことが多い。

"debugger文は実際の開発で使用する方がよいのでしょうか？
私が今まで携わったプロジェクトでは使用しているところを見たことがないと思うので気になりました。"
-> 正直消し忘れるのが見えているのであまり使わない。

"フォーマッタで整形できない部分についても開発チームごとに決まりごとがあるのでしょうか？
例えば、if文の入れ子にするのではなく、else-ifを使わなければならない。やfor/inではなくfor/ofを使わなければならない。exportはexport defaultの形式で書かなければならない。など
コーディングを行う部署に属していないため質問です。"
https://eslint.org/docs/latest/rules/no-lonely-if
https://typescript-eslint.io/rules/no-for-in-array/
