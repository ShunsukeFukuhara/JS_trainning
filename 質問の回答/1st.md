> 開発者コンソールで宣言した変数のスコープはどこまででいつまで有効なのでしょうか？（ページごととか？更新したら無効になるとか？）

ページ更新や１実行単位で有効だと思う。それらが終わるとメモリ領域が丸ごと消し飛ばされるため無効。

> JavaScriptは「従来のオブジェクト指向プログラミング言語とは非常に異なったものになっています。」とありますが、具体的に言うと？フィールド変数を別途宣言する必要なくて、コンストラクタ内で初めて宣言するところとか？

プロトタイプベースの言語。
[よさげ](https://zenn.dev/aidemy/articles/class-prototype-of-js#fn-934b-1)

> 「必要以上にメモリを使い続けたくない場合には、必要ではなくなった値を参照できなくなるように、プログラムを記述してください」とは具体的にどうするの？

イベントリスナを解除するとか
ポーリングの出口を作るとか

> 「BigIntの実装は、タイミング攻撃に耐性がないので、暗号に使うのは避けた方がよいでしょう」が理解できない
> タイミング攻撃は、コンピュータシステムやアルゴリズムが処理にかかる時間を観察することで、システム内部の情報を盗み出す攻撃の一種です。
> 具体的には、暗号化や署名、認証などの処理にかかる時間が入力によって異なる場合、その時間の違いから何らかの情報を推測することができます。

BigIntを使う場合、その計算がタイミング攻撃に脆弱な可能性があり、暗号学的な用途には注意が必要です。
暗号アルゴリズムでは、計算時間が入力に依存しないような定時間演算が必要であり、BigIntはそれに適していないことが多いです。

そのため、暗号処理においては、タイミング攻撃に耐性を持つ専用のライブラリや方法を使用することが推奨されています。

> 処理時間の違いがわかってしまうから耐性ないということ？なぜそれだけで耐性がないとなるのか。またBitIntの使いどころはどこか。

そもそも処理時間が長くなるからタイミング攻撃に弱い。
とはいえ暗号化では使うし、定時間演算を適切に扱えば問題ない。
金融、天文学、画像処理、ゲームのスコア計算など

> 「BigIntの実装は、タイミング攻撃に耐性がないので暗号に使うのは避けた方が良い」と記載されていますが、Numberの場合は演算速度が値に依存せずタイミング攻撃に耐性があるのでしょうか？

相対的にYes。しかし完全ではない

> BigIntの演算速度は桁の大きさに影響を受けると理解したのですが、BigIntの演算速度がnumberより早くなるような場合はあるのでしょうか？

Number型:
浮動小数点演算に基づいているため、演算が高速で、CPUの標準的な浮動小数点演算命令を使って処理されます。
特に、整数に関する演算が非常に効率的です（最大2^53 - 1まで）。
演算の時間は、演算対象の数値が小さい場合に最も速く、数値が大きくなると計算速度が低下します。これは、浮動小数点数で扱える範囲内であれば、その範囲内での演算が非常に高速で行えるためです。

BigInt型:
大きな整数を扱うため、演算時には 大きなメモリ領域 と 複雑な計算手順（例えば、数値の桁を1つずつ計算するなど）を必要とします。そのため、BigIntはNumber型よりも計算が遅くなる傾向があります。
BigIntの演算速度は桁数に比例して遅くなるため、扱う数値が非常に大きくなると、計算コストが急激に上昇します。

大きいNumberより小さいBigIntの方が早い場合はありそう。

> 「長さ2のJavaScript文字列が表しているのが、1文字のUnicode文字という場合もあります」と書かれていますが、正確に文字列の長さを取得するにはどうすればよいでしょうか？

lengthプロパティは、UTF-16の「コード単位」の長さを返しますが、サロゲートペアで表される文字は2カウントされてしまいます。
Array.from()やfor...ofループを使うことで、Unicodeの「文字数」を正確に取得できます。

> 「サロゲートペアに対して特別な処理を行わない」とありますが、どのようにしてサロゲートペアかそうでないかを判断しているのでしょうか？また、サロゲートペアに関して、基本的にプログラマーは意識しなくて良い物なのでしょうか？

サロゲートペアは通常の文字列操作で意識しなくても良いことが多いです。
特別な処理が必要な場合（文字列を正確に「文字」単位で処理したいときなど）にサロゲートペアを意識する必要があります。
JavaScriptでは、サロゲートペアを自動的に処理してくれるため、一般的には特別な対応をしなくても問題はありませ

> 「テンプレートリテラルには、複数の式を含めることもできます」とありますが、可読性やバグ防止の観点から、重い処理や複雑な式は避けた方がよいのではないかと感じました。テンプレートリテラル内に含める式は、どの程度までなら実用的・安全とされているのでしょうか？

(個人の感想だが)１つのテンプレートの枠には変数１つまでが良いと思う。

> !==と!(...===...)の違いは何でしょうか？

ほぼ同じに見える。!==の方が良さそう

> undefinedはエラーのようなものと1行目に書いてありますが、nullではなくundefinedを使う理由はなぜなのでしょうか。

どちらかというとnullを使う意味合いの方が強い。nullは処理結果がnullであったことを明示するものである。undefinedは処理が値を返さないか、まだ何も処理していないか、処理がエラーになった結果「値が代入されなかった」を暗示している
undefinedの解釈は結構多いので、これを明示的に取り扱うのは避けたい

あるものの欠如を意味する型
null 値の欠如
undefined 割り当てられていない
void return文を持たない関数の戻り値
never 絶対返らない関数の戻り値

> Symbol.forについて。
> Symbolは同じ引数を渡した場合でも異なる一意の値を返すため、既存のプロパティを上書きしないことが強みだと理解しました。しかし、Symbol.forでは同じ引数を渡した場合、同じ値を返します。
> そのため、Symbolの強みの部分が消えており、文字列を使ってプロパティにアクセスするのとあまり変わらないように感じました。文字列によるアクセスではなく、Symbol.forを使うケースを教えていただきたいです

Symbol.for は、同じシンボルを複数のモジュールやコードで共有したい場合に役立ちます。これにより、名前の衝突を防ぎつつ、一貫性を持たせることができます。文字列を使う場合には衝突する可能性が高く、意図的に隠蔽したいプロパティに対しては、Symbol の方が優れた選択となります。

> オブジェクトを基本型値に変換するための基礎となるアルゴリズムの３つ目に優先度なしというのが説明されていますが、内容読むとJavaScriptに組み込まれている型の中ではDate以外は数値優先でDateは文字列優先と記載があります。つまり、優先度なしアルゴリズムを採用しているものは無いのでは？

このプロセスで「優先度なしアルゴリズム」という表現が使われるのは、オブジェクトが基本型に変換される際に、どちらが優先されるかという固定の優先順位はなく、基本的にはそのオブジェクトに定義されたメソッド（valueOf() や toString()）によって決まるためです。これは、オブジェクトの種類によって異なる振る舞いをすることを意味します。

> JavaScriptの抽象的等価比較（==）では、異なる型の値を比較する際に内部で型変換が行われますが、例えば a.getTime() == a のように、数値とDateオブジェクトを比較した場合、 Dateは文字列優先変換なので、JavaScriptは a を文字列に変換して比較しようとし、最終的に false になります。
> このとき、なぜJavaScriptは「まず文字列で比較してダメだったら、次に数値で比較する」といった別の型変換を試さないのでしょうか？
> 一度決めた型変換ルールに従って比較を行い、他の変換ルートを再試行しない理由を教えていただきたいです。

なぜ文字列変換だけを試すのか
JavaScriptでは、型変換の優先順位が厳密に決められており、変換の順序が予測可能です。つまり、==演算子で型が異なる場合は、どの変換ルートを試すかが仕様で定義されており、最初の変換ルートで不一致があれば、その後のルートは試されません。

具体的には、オブジェクトと基本型の比較の場合：

オブジェクトが数値、文字列、boolean などの基本型に変換されます。

文字列への変換が最初に行われ、その後に数値への変換が試みられることはありません。toString()が呼ばれ、変換後にその型（文字列）の結果を比較します。

パフォーマンスが悪くなりそう

> 「var宣言の最も変わった特徴の一つにホイスティング(巻き上げ)と呼ばれるものがあります」とありますが、varがどうしてホイスティングができるような設計にしたのかわかりませんでした。わざわざ変数を後で宣言してもOKにしたのは、メリットや理由があったのでしょうか？バグの可能性や可読性よりも良い点があったのか気になりました。

宣言型のUIでは順序がそこまで重要でなく、当時はcssのようにjsもスクリプトを追加する程度の目的だったため、scriptを下に集めたりできるのが良さげだった

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sample Page</title>
</head>
<body>
    <button onclick="sayHello()">Click me</button>

    <script>
        // この位置にスクリプトを書いても
        // ホイスティングで「変数宣言が自動的に先頭に移動」するため問題なく動作します
        function sayHello() {
            alert('Hello!');
        }
    </script>
</body>
</html>
```
