> 関数式を使い慣れておらずconstしか使っていないため、条件付き呼び出しの利用イメージがわいておりません。letで後から書き換えたり、とりあえず定義したりしたい場合に、使うのでしょうか。とりあえず条件付き呼び出しにした方が安全ということなのでしょうか。

関数をコールバックの引数に設定している時使う

> 関数をオブジェクトとして扱えることで拡張性の高さというメリットが生まれる反面、制約がないと可読性の低下や構造の不明瞭さが発生しやすいと思った。8章では関数のプロパティとメソッド、高階関数など色々出てきたがどの程度実務で使用してよいのか。

| 機能                                             | 実務での使用         | 説明                                                                |
| ------------------------------------------------ | -------------------- | ------------------------------------------------------------------- |
| 関数にプロパティを付ける                         | ❌（特殊な場合のみ） | ほとんど使われない。クラスやクロージャで代替する。                  |
| 関数にメソッドを付ける（関数に関数をぶら下げる） | ❌                   | 見通しが悪くなる。モジュールやオブジェクトで管理すべき。            |
| 高階関数                                         | ✅ 重要              | `map`, `filter`, `reduce`, カスタムコールバックなどで広く使われる。 |
| コールバック関数                                 | ✅                   | `addEventListener` や `Array.prototype.map()` など。                |
| 関数を返す関数（クロージャ）                     | ✅（適切に使えば）   | 状態を隠したり、設定済みの関数を返す場面などで有効。                |
| 関数を引数として受け取る関数                     | ✅                   | 高階関数の基本形。多用される。                                      |

> Argumentsオブジェクトについて、「非Strictモードでは、非効率的で最適化の難しい歴史的な負債になっています」とありますが、どのような所で最適化が難しい歴史的な負債になっているのでしょうか？

function slowFunction(a, b) {
arguments[0] = 100;
return a + b;
}
→ エンジンは a の値を定数として最適化できない。

> クロージャについて、関数の外の変数を保持できるという仕組みなのは理解したのですが、
> 実際には なぜ関数の実行が終わった後でもその変数が破棄されずに残っているのか、JavaScriptのスコープやメモリの仕組みのどの部分が関係しているのかがよくわかりません。
> また、クロージャを使うと何が便利なのか、グローバル変数と比較してどんなメリット・デメリットがあるのかも知りたいです。
> 実際の開発ではどういう場面でクロージャが効果的に使われているのか、具体的な使用例があれば教えていただきたいです。

```
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}
const fn = outer(); // outer() は実行されたが、戻り値の inner() を fn に保持
fn(); // 1
fn(); // 2
```

outer() の実行は終了しても、inner() 関数が count にアクセスしているので、count は消さない（inner が参照している限り）。→ これがクロージャ。

| 比較項目     | クロージャ                                       | グローバル変数                             |
| ------------ | ------------------------------------------------ | ------------------------------------------ |
| **スコープ** | ローカルに閉じている（安全）                     | どこからでもアクセス可（衝突の危険）       |
| **再利用性** | 関数ごとに状態を持てる                           | 状態が共有されてしまう                     |
| **安全性**   | 意図しない変更が起きにくい                       | 他の関数から勝手に書き換えられる可能性あり |
| **メモリ**   | 適切に管理しないとメモリリークの原因になることも | 同様に注意は必要                           |

init

```
const initOnce = (() => {
  let initialized = false;
  return () => {
    if (initialized) return;
    console.log("初期化処理");
    initialized = true;
  };
})();

initOnce(); // 初期化処理
initOnce(); // 何もしない
```

モジュールパターン

```
const CounterModule = (() => {
  let count = 0;

  return {
    increment: () => ++count,
    reset: () => { count = 0; },
    getCount: () => count,
  };
})();

CounterModule.increment();
console.log(CounterModule.getCount()); // 1

```

> 関数のlengthプロパティは規定値のある最初の引数より前の引数だけカウントするとのことですが(本ではなくmdnに書いてありました)、なぜこのような仕様なのでしょうか？規定値を持つ引数をカウントしてほしい場合は関数内でundefinedチェックをして規定値を入れる対応を取るのでしょうか？

必須な引数の数が分かる

| 項目             | 内容                                                                 |
| ---------------- | -------------------------------------------------------------------- |
| なぜ？           | `.length` は「必須の引数の数（arity）」を返すため                    |
| 含めたいときは？ | 関数内のロジックや関数定義文字列を解析するしかない                   |
| 今後の対応       | TypeScript や JSDoc などで補完し、`.length` はあくまで参考として使う |

> メモ化をすることで、直前に計算された結果をキャッシュとして保持しておくのは次回以降に計算するコストが削減されて便利だと感じました。
> 一方で、メモリを大幅に使用するものだったり、計算コストのかからないものは使わなくても良いとも感じたため、どの判断基準を持って使用するかを決めるべきかが気になりました。実際に処理を書く際にメモ化処理を入れるか迷った時はどう決めていけば良いでしょうか？

大きな配列の操作とか、メモ化しないとパフォーマンスが悪くなる場合はメモ化を検討する。
→明らかに計算コストが高そうな場合は検討に値する

> 関数のlengthプロパティは引数の数に応じた処理をしたい場合などに使うのかなと思ったのですが、残余パラメータは含まれないとのことなので、引数に残余パラメータがあった場合に思惑と違う動作をしそうです。このプロパティを使う場面はあるのでしょうか？その関数に残余パラメータが存在するということがわかる方法があるのでしょうか？

メタデータが必要な場合に使う。

> 関数型プログラミングについて、「目的は、JavaScriptの関数の力を紹介することです。このようなプログラミングスタイルを推奨しているわけではありません。」という記述があり、P.238の最後でも同じような記載があります。これは推奨しないという意味ではなく、よく考えて使ってねという意味と理解すれば良いでしょうか？
> 関数型プログラミングで記載した方が可読性が良い場合も多々あると思いますが、JavaScriptでも、副作用がない（外部の状態や変数が変数名とは違うものに変更されないなど）ように気を付けて使えば、関数型プログラミングで記載するのも一般的に使われるという理解で良いでしょうか？

| シーン                   | 関数型が向いている理由                               |
| ------------------------ | ---------------------------------------------------- |
| 配列の加工               | `map`, `filter`, `reduce` などで副作用なく変換できる |
| ロジックの分離           | 小さく純粋な関数に分けることでテストしやすくなる     |
| 状態の変更を避けたいとき | **不変性（immutability）** を守りやすい              |
| 並列処理や非同期処理     | 副作用がないことで安全に非同期処理ができる           |

| 注意点               | 理由                                                         |
| -------------------- | ------------------------------------------------------------ |
| 読みにくくなりすぎる | `reduce` や合成関数を多用しすぎると逆に理解が困難に          |
| パフォーマンス       | イミュータブルな操作がオブジェクトをコピーしすぎると重くなる |
| チームの理解度       | FPに慣れていない人が読めないと保守性が下がる                 |

> なぜES6までclassキーワードは導入されていなかったのでしょうか？個人的にはclassキーワードでの実装の方が見ていて分かりやすく、同じ動きをすると認識していますが、それなら序盤からあってもおかしくないと思いました。

| 項目                          | 内容                                                       |
| ----------------------------- | ---------------------------------------------------------- |
| なぜ昔は `class` がなかった？ | 言語の初期思想がプロトタイプベース。軽量な構造を優先した。 |
| なぜ後で導入された？          | 大規模開発、他言語経験者の流入で構文糖が求められた。       |
| `class` の正体は？            | 実態は `prototype` の構文糖。挙動は同じ。                  |

> プロジェクトでTSを使っており、private ではなく # を使っています。他のところではどちらを使っていますでしょうか？また、使い分けに理由がある場合は教えていただきたいです（）

どちらもあまり使ってない
基本データ型の定義や、クラスのメソッドに対しては `private` を使うことが多い。
`#` は主に、JavaScriptの最新機能を使いたい場合や、クラスの内部でのみ使用するプロパティに対して使われる。

> 「スーパークラスがサブクラス化されている」というのがどのような状態で、「new.target.name」を出力すると何がわかるのかがわかりませんでした。

被写体を撮影するみたいな

Animal のコンストラクタが直接 new Animal() で呼ばれたのではなく、
class Dog extends Animal によってサブクラス化されて 間接的に呼ばれた ということ。

```
class Animal {
  constructor() {
    if (new.target === Animal) {
      throw new Error("Animal は直接インスタンス化しないでください");
    }
  }
}

class Dog extends Animal {}

new Animal(); // ❌ エラーになる
new Dog();    // ✅ OK
```

インターフェース的な

> 「継承よりも合成」の理由は以下だと思っているのですが、あっていますか？
> ・継承はクラスの構造が複雑になり、保守やテストが難しくなる
> ・合成は拡張や機能の書き換えなど柔軟性がある
> また、どのような場合に、合成ではなく、継承を使うことがあるのでしょうか？（チームの方針？）

✅ 継承より合成を選ぶ理由
継承は構造を固定化しやすい
→ 深い継承階層は理解・保守が難しい

継承は強い結合を生みやすい
→ 親クラスの実装に依存しやすく副作用が起こりやすい

合成は柔軟で再利用しやすい
→ 必要な機能を好きなように組み合わせられる

テストしやすい
→ 小さな部品ごとに切り離してテスト可能

✅ 継承を使うケース
「IS-A（〜は〜である）」の関係が明確な場合
例：Dog は Animal の一種

共通処理を親クラスでまとめたい場合
→ 共通メソッドやフィールドの再利用が楽

フレームワークやライブラリの設計方針
→ 既存の継承構造を利用するため

パターンや仕様で継承を前提としている場合
→ 例：抽象クラス・インターフェースの実装

✅ まとめ
