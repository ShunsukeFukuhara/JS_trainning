> 普段業務でES6のモジュール方式(import, export)を多く見かけているのですが10章で学んだ他の方式を使うメリット、場面はあるのでしょうか？

| 項目                    | 内容                                                     |
| ----------------------- | -------------------------------------------------------- |
| 他の方式のメリット      | 古いブラウザやNode.jsのバージョンでの互換性がある。      |
| 使う場面                | レガシーコードの保守や、特定のビルドツールを使う場合。   |
| ES6モジュールのメリット | 静的解析が可能で、ツリーシェイキングや最適化がしやすい。 |

> JavaScriptではMapのキーやSetの要素が参照ベースで管理されるため、
> オブジェクトなどの可変値も利用可能である一方でPythonではハッシュベースで管理されるため、
> 不変値しかキーや要素として利用できません。この違いはどのような設計思想に基づくものですか？
> また、それぞれの設計にどのようなメリット・デメリットがあるのでしょうか。

設計思想か謎だが、jsではhashcodeという仕組みを持っていないので、参照同一性を見ている。基本型しか受け付けないことも可能かもしれないが、、、
Mapが出来たのはES6からだった。それまでは連想配列はオブジェクトを使っていた。

キャッシュしたいという要望があった？
https://github.com/tc39/proposal-policy-map-set?utm_source=chatgpt.com

> 「Setクラスは要素が挿入された順番を覚えている」とありますが、
> Setは順番に関係なく重複がない要素が入っているというのが特徴で、何番目を取り出すといった操作はできないと思いますが、
> 内部的に順番を覚えていることで有効なことや考慮することはあるのでしょうか？

| 項目            | 内容                                                           |
| --------------- | -------------------------------------------------------------- |
| Setの順番の特徴 | 挿入順を保持することで、イテレーションの順序が保証される。     |
| 有効なこと      | イテレーションや順序に依存するアルゴリズムが簡単になる。       |
| 考慮すること    | 順序が保証されるため、パフォーマンスに影響が出る可能性がある。 |

> 型付き配列のメリットとして、処理速度やメモリ効率の向上だと思うのですが、実際の開発では、最初から型付き配列を使用して書くことはあるのでしょうか？
> 基本的に、リファクタリングを行う際に、配列から型付き配列に変更するという流れでしょうか。
> （質問を書いていて、バイナリデータの処理の際には最初から型付き配列を使用するような気もしてきました。。。）

| 項目                     | 内容                                                                                         |
| ------------------------ | -------------------------------------------------------------------------------------------- |
| 型付き配列の使用場面     | バイナリデータ処理やパフォーマンスが重要な場面で使用される。                                 |
| リファクタリングの流れ   | 最初は通常の配列で開発し、パフォーマンスが問題になった場合に型付き配列に変更することが多い。 |
| 最初から型付き配列を使う | バイナリデータやパフォーマンスが極めて重要な場合に限られる。                                 |

明らかにデータ量が膨大な時には検討する

> 複数ビューを使うときはArrayBufferを使う、単独ビューだけ使うときはTypedArrayのみという使い分けの理解で合っているでしょうか。
> これまで同じバッファで複数のビューなどは意識したことがなかったのですが、とりあえずArrayBufferで領域を確保した方が後々のためにいいのでしょうか

| 項目                | 内容                                                      |
| ------------------- | --------------------------------------------------------- |
| ArrayBufferの使い方 | 複数のビューを使う場合はArrayBufferを使用する。           |
| 単独ビューの使用    | 単独のTypedArrayで十分な場合はTypedArrayのみを使用する。  |
| 使い分けの理由      | ArrayBufferはメモリ効率が良く、複数のビューを共有できる。 |

後々の拡張予定がない場合はTypedArrayのみで十分なこともある。過度に拡張余地を持たせる必要はない、と思う

> 「型付き配列とDataViewを使えば、バイナリデータを処理することができます。」の部分で、実際にZIPファイル展開する方法のイメージができなかったので具体的な方法を知りたいです

ZIPファイルはバイナリ形式で圧縮されたデータを含むため、JavaScriptで処理するには以下のような手順が考えられます。

1. **ZIPファイルの読み込み**: `fetch` APIや`FileReader`を使ってZIPファイルを読み込みます。
2. **ArrayBufferの取得**: 読み込んだデータを`ArrayBuffer`に変換します。
3. **DataViewの作成**: `ArrayBuffer`から`DataView`を作成します。
4. **ZIPファイルの解析**: ZIPファイルのフォーマットに従って、`DataView`を使ってヘッダー情報やファイルデータを読み取ります。
5. **ファイルの展開**: 読み取ったデータを元のファイル形式に変換し、必要に応じて解凍処理を行います。
6. **結果の利用**: 展開したファイルをブラウザで表示したり、ダウンロードリンクを生成したりします。

```javascript
async function parseZip(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  const files = [];

  const LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
  let offset = 0;

  while (offset < view.byteLength) {
    if (view.getUint32(offset, true) !== LOCAL_FILE_HEADER_SIGNATURE) break;

    const nameLength = view.getUint16(offset + 26, true);
    const extraLength = view.getUint16(offset + 28, true);
    const compressedSize = view.getUint32(offset + 18, true);
    const uncompressedSize = view.getUint32(offset + 22, true);

    // ファイル名を取得
    const nameBytes = new Uint8Array(arrayBuffer, offset + 30, nameLength);
    const filename = new TextDecoder().decode(nameBytes);

    // データ本体のオフセット
    const dataOffset = offset + 30 + nameLength + extraLength;

    files.push({
      name: filename,
      compressedSize,
      uncompressedSize,
      dataOffset,
    });

    // 次のファイルへ
    offset = dataOffset + compressedSize;
  }

  return files;
}

// 使い方例
const arrayBuffer = await fetch("sample.zip").then((r) => r.arrayBuffer());
const zipFiles = await parseZip(arrayBuffer);

zipFiles.forEach((f) => {
  console.log(f.name, f.compressedSize, f.uncompressedSize, f.dataOffset);
});
```

> 正規表現のの生成には//で囲むリテラル表現とRegExp()コンストラクタを使う場合の２種類がありますが、この２つの生成方法の使い分けのポイントはありますか？
> RegExp()コンストラクタは正規表現を動的に生成できるのが便利なポイントなので、とりあえず動的に生成しないといけないときはRegExp()コンストラクタを使う、それ以外はリテラルで良いという認識で合ってますでしょうか？
> | 項目 | 内容 |
> | ------------------------ | -------------------------------------------------------------------------------------- |
> | リテラル表現の特徴 | 静的な正規表現を簡潔に記述でき、パフォーマンスが良い。 |
> | RegExp()コンストラクタの特徴 | 動的に正規表現を生成でき、変数や式を使って正規表現を構築できる。 |
> | 使い分けのポイント | 静的な正規表現はリテラルで、動的な正規表現はRegExp()コンストラクタを使用する。 |
> 例えば、ユーザーからの入力を元に正規表現を生成する場合はRegExp()コンストラクタを使うことが多いです。

> Dateオブジェクトはこれまでタイムゾーンの扱いが直感的でなかったり月が0始まり出なかったりといった点で扱いづらいものであると感じました。
> 調べていく中で、最近Temporal APIが開発されていると知り、これを使うことで日付や時間の処理がより扱いやすくなりそうなことが分かりました。
> では将来的に、Temporal APIはDateオブジェクトを置き換わっていくのか、それとも補完的に併存していくのか、
> そもそもTemporal APIは使用されずにDateのみのままなのかその立ち位置がどうなると考えられるのか知りたいです。

新規プロジェクトではTemporal APIを使うことが推奨されている。Dateオブジェクトはレガシーなものとして残る可能性が高い。

> Date APIの注意点として「最初の月は0になりますが、最初の日は１になります。」とあります。
> 何故このような仕様なのでしょうか？ミスを誘発するだけに思えます。
> 調べた結果、JavaのDateを参考にしたとのことですが、Javaは新たに月を1~12で表現するLocalDateが導入されたようです。
> JavaScriptも月を1~12で表現するように改善されないのでしょうか？

JavaScriptのDateオブジェクトは、JavaのDateを参考にしているため、月が0始まりになっている。これは歴史的な理由であり、改善される可能性は低い。
ただし、Temporal APIでは月は1から始まるため、将来的にはこちらが主流になる可能性が高いです。

> 「Web上で高精度な時間処理ができると、不正なWebサイトが訪問者を識別できる」とありますが、なぜ識別できるのでしょうか？
> 加えて、ブラウザ(特にFirefox)の場合はデフォルトでperformance.now()の精度を落としているとありますが、Google ChromeやEdge,Safariなどでは精度を落としていない...という事なのでしょうか？

ブラウザ指紋
Webサイトが訪問者の操作やレンダリング処理時間を 非常に高精度で測定 できる
これにより、ユーザーの環境（CPU 性能、ブラウザのレンダリング特性、OS、GPU など）に依存した微妙な差異を観測可能
この「微妙な差の集合」が 個人や端末ごとにほぼユニーク になることがあります

https://developer.chrome.com/blog/meltdown-spectre?hl=ja
