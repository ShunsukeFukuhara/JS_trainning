> フロントエンドフレームワークは Web Components を作ってくれるのか！と思いましたが、違うようです。Web Components はどういった場面で使われるのでしょうか？

Web Components は、再利用可能なカスタム要素を作成し、HTML、CSS、JavaScript を組み合わせて独自のコンポーネントを定義できる技術です。フロントエンドフレームワーク（例えば React、Vue、Angular など）は、コンポーネントベースの開発をサポートしますが、Web Components はブラウザネイティブの技術であり、フレームワークに依存しない形でコンポーネントを作成できます。

マイクロフロントエンドアーキテクチャのように、異なるフレームワークやライブラリを組み合わせて大規模なアプリケーションを構築する場合、Web Components はフレームワーク間の互換性を提供する手段として有用です。また、企業内で共通の UI コンポーネントライブラリを作成し、複数のプロジェクトで再利用したい場合にも役立ちます。

> Web Components で、HTML 属性に対応する JavaScript プロパティを定義していない場合は、getAttribute / setAttribute を使ってアクセスすることになると思っています。
> 実務や一般的な設計の観点からは、ほぼ必ず属性に対応するプロパティを定義した方が良いのでしょうか？
> また、そもそも React や Vue などのフレームワークのコンポーネントを利用するようになり、Web Components は実務であまり使われないのでしょうか？
> ✅ 属性に対応するプロパティの定義
> 一般的には、HTML 属性に対応する JavaScript プロパティを定義することが推奨されます。これにより、開発者は直感的にコンポーネントを操作でき、コードの可読性と保守性が向上します。ただし、特定のユースケースやパフォーマンス要件によっては、属性のみで十分な場合もあります。

✅ Web Components の実務利用
React や Vue などのフレームワークが広く使われているため、Web Components の利用は限定的かもしれません。しかし、特定のプロジェクト要件や組織の方針によっては、Web Components が選択されることもあります。特に、フレームワークに依存しない再利用可能なコンポーネントが必要な場合や、異なるフレームワーク間での互換性が求められる場合には、Web Components が有効な選択肢となります。

> RICOH UI Design Systemというものがあると思います。(https://share.dev.smart-integration.ricoh.com/ricohui/ja/components/accordion.html) こちら、WebComponentのカスタム要素によって作られているのでしょうか？
> また、<rui-accordion> | RuiAccordion というようにHTMLとReactの2バージョン提供されています。これは、WebComponentをReact コンポーネント風にラップして提供されているのでしょうか？

createComponent は Lit が提供しているWeb Components → React コンポーネント変換ツールです。
RICOH UI Design System の <rui-accordion> コンポーネントは、Lit を使用して作成された Web Components であり、React コンポーネントとしても利用できるようにラップされています。これにより、開発者は React 環境でも同じコンポーネントを簡単に使用できるようになります。

> 「カスタム要素のインスタンスがドキュメントに挿入されると、connectedCallback()が呼び出されます」とありますが、コンストラクタではだめなのでしょうか？1行前に「コンストラクタを持つ場合」という記述もあるので使い分けされているようですが、どのような使い分けなのかがわかりませんでした。

コンストラクタは、カスタム要素のインスタンスが生成されるときに呼び出されますが、ドキュメントに挿入される前に実行されます。そのため、コンストラクタ内で DOM 操作や外部リソースへのアクセスを行うと、まだ要素がドキュメントに存在しないため、期待通りに動作しないことがあります。

constructor では DOM にアクセスできない

> 「シャドウルートは「open」モードで作成するのが一般的です。」とありますが、なぜでしょうか？
> DOMのカプセル化が目的であれば、情報秘匿性が高い「closed」モードの方がよい気がしました。
> 「open」モードの方がテストはしやすいと思うので、例えば開発は「open」モードで行い、リリース時に「closed」モードに変更したりするのでしょうか？

closed シャドウ DOMは：
const shadow = this.attachShadow({ mode: "closed" });

として作りますが、開発者ツールでは普通に見えるCSS や JS で DOM を隠せるわけではないセキュリティや著作権保護の効果は一切ない
つまり closed は言い換えれば
「JavaScript で .shadowRoot を取得できないだけ」

> 静的な画像やアイコンについては別ツールで作成したものや既存で作成したものを添付する、動的な画像についてはSVGやCanvasを使うという理解をしました。みなさんが担当しているテーマでもSVGやCanvasを使った動的な画像作成はよく行われるのでしょうか？(グラフの作成とか、画像処理とかで使ったりするのでしょうか？)

ない。

> SVGで要素をひとつひとつ描くのは大変だなと思ったのですが、実業務ではSVGを簡単に書くためのツールとしてどういったものを使うのでしょうか？出来合いのライブラリのようなものを活用することも多いのでしょうか？
> デザインツールで作って流し込むのが一番良い

> 「#topという識別子は特別です。id=“top”属性を持つ要素が存在しない場合、ブラウザはドキュメントの先頭を表示します。」とありますが、このような特別な識別子は他にあるのでしょうか？

また、特別な識別子にするならば他の箇所でid=“top”を指定できないなどのルールがあったほうが混乱を招かずに良いのではないかと思ったのですが、そういったルールがないのはどうしてでしょうか？
https://qiita.com/ginpei/items/129969dda33856268057

> 「Historyオブジェクトには、ドキュメントのリスト形式で、ウィンドウの閲覧履歴が格納されています」とありますが、閲覧履歴が破棄されるタイミングとしてはどこになるのでしょうか？セッションが終了した時等になるのでしょうか？

Historyオブジェクトの履歴は タブ・ウィンドウ単位のセッション履歴
タブ/ウィンドウを閉じる または ブラウザを終了する と破棄される

> hashchangeとpushState現場ではどのように使い分けられていますか？

hashchange は URL のハッシュ部分（#以降）が変更されたときに発生するイベントで、主にシングルページアプリケーション（SPA）でのナビゲーションに使用されます。一方、pushState は History API の一部で、URL を変更しながらページの状態を管理するために使用されます。

hashchange は URL の一部を変更するだけで、ページのリロードを伴わないため、軽量なナビゲーションに適しています。pushState はより柔軟で、URL の変更に加えて、ページの状態（例えば、表示されるコンテンツやフォームの入力状態など）も管理できるため、より複雑なアプリケーションに適しています。

例えば、簡単なタブ切り替えやセクションの表示・非表示には hashchange を使用し、フォームの送信やフィルタリングなど、状態管理が必要な場合には pushState を使用することが一般的です。

余程古いブラウザとの互換性を考慮しない限り、pushState の方が柔軟で強力なため、現代のウェブアプリケーションでは pushState が主に使用される傾向があります。
そもそもルーティングやURL管理は直接扱うよりも、React Router や Vue Router などのライブラリを使用することが一般的です。
